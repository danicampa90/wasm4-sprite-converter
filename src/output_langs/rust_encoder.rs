use super::{Encoder, OutputDevice};
use crate::{errors::AppError, output::OutputResult};

pub struct RustEncoder {}
impl RustEncoder {
    pub fn new() -> Self {
        Self {}
    }
}

impl Encoder for RustEncoder {
    fn write_to(
        &self,
        tiles: &OutputResult,
        writer: &mut dyn OutputDevice,
    ) -> Result<(), AppError> {
        writer.write_str("// Autogenerated by tilemap2src\n\n")?;
        for tile in tiles.iter() {
            writer.write_str(&format!("// -- {}\n", tile.name()))?;
            // write data declaration
            writer.write_str(&format!(
                "pub const TILEDATA_{}: [u8; {}]= [",
                tile.name(),
                tile.bytes().len()
            ))?;
            // write bytes in the array
            for byte in tile.bytes() {
                writer.write_str(&format!("{},", byte))?;
            }
            // end byte array
            writer.write_str("];\n")?;
            writer.write_str(&format!(
                "pub const TILE_{}_WIDTH: u8 = {};\n",
                tile.name(),
                tile.width_pixels()
            ))?;
            writer.write_str(&format!(
                "pub const TILE_{}_HEIGHT: u8 = {};\n",
                tile.name(),
                tile.height_pixels()
            ))?;
            writer.write_str(&format!(
                "pub const TILE_{}_BPP: u8 = {};\n",
                tile.name(),
                tile.bpp()
            ))?;
            writer.write_str("\n\n")?;
        }
        Ok(())
    }
}
